多态性的分类
多态性可以分为四类，C++ 支持所有这些类别：
# Ad-Hoc Polymorphism （临时多态性）
临时多态性是一种表面上的多态性，其多态性在深入分析后会消失。它分为两种：

## `Coercion（强制转换）`：
通过修改参数类型来匹配函数定义中的参数类型，避免类型错误。例如，C++ 中的隐式类型转换。
- Narrow the argument type (narrowing coercion) *丢失精度或数据风险，通常需要显式转换*
- Widen the argument type (promotion) *目标类型的范围和精度比源类型更大、更安全*

## `Overloading（重载）`：
允许同一函数名用于不同的参数类型，每个参数类型有独立的函数定义。C++ 通过函数签名（函数名 + 参数类型）来区分重载函数。
- （*程序语言（比如C）不接受重载*）


# Universal Polymorphism（通用多态性）
通用多态性是真正的多态性，其多态性在深入分析后仍然存在。它分为两种：

## `Inclusion（包含多态性）`：
通过继承层次结构中的对象类型选择成员函数定义。C++ 通过虚函数表（vtable）在运行时实现。
- （非虚函数在继承中会导致“遮蔽”（shadowing）这种行为与多态无关，是作用域和名称解析的结果）

## `Parametric（参数化多态性）`：允许函数定义独立于类型，适用于任何类型。C++ 通过模板（template）在编译时实现。